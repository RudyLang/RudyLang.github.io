---
layout: post
title: "Game Crash Reporter"
date: 2020-09-14 21:22:00 -0000
categories: software
image: bug_reporter_app.PNG
summary: "I combine ExpressJS, VueJS, and MySQL to create a fullstack error reporting system."
tags: NodeJS ExpressJS VueJS MySQL C#
featured: true
---

<img class="myImg" src="/post_images/bug_reporter_app.PNG">

<!-- The Modal -->
<div id="myModal" class="modal">
  <span class="close">&times;</span>
  <img class="modal-content" id="img01">
  <div id="caption"></div>
</div>

### Project Highlights:
* [Motivation](#BugReport-Motivation)
* [Setting Up The MySQL Database](#BugReport-MySQL)
* [Backend](#BugReport-Backend)
* [Frontend](#BugReport-Frontend)
* [Crash Reporter](#BugReport-Crash-Reporter)

### <a id="BugReport-Motivation"></a> Motivation
I believe that developing tools to support your team and your product is useful skillset for a proficient Software Engineer. For this project I wanted to demonstrate the use of web applications to better manage error reports being generated by players.  I invisioned the structure as such:

*MySQL database to store all report related content
*ExpresJS backend to handle calls to the database
*VueJS frontend to display important details to the developer
*Mock crash report to submit new errors

### <a id="BugReport-MySQL"></a> Setting Up The MySQL Database
For the minimal-viable-product (MVP) I needed a datbase that would store basic report information such as: error type, comments, time, and date. I set it up as follows:

<img class="myImg" src="/post_images/sql_table_reports.PNG">

I chose to seperate date, hour, and minute into their own columns to make parsing the data easier on the front-end. This way I can directly access those JSON objects without having to write new functions to extract information from the timestamp. I also chose these three identifiers because they made sense from a graphicaly representation; viewing occurence of daily, hourly, and minutely.

### <a id="BugReport-Backend"></a> Backend
ExpressJS is my weapon of choice for the backend. I've always liked how thinly it integrates into NodeJS.
I setup my server and routes as such:

<div class="article-code">
<pre>
//server.js

require('dotenv').config();

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors')
const app = express();

app.listen(process.env.EXPRESS_PORT);

app.use(cors())
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

var routes = require('./app/routes/routes');
routes(app); // Register the route
</pre>
</div>

<div class="article-code">
<pre>
//db.js

require('dotenv').config();

const mysql = require('mysql');

// Setup MySQL Connection
var connection = mysql.createConnection({
    host: "127.0.0.1",
    user: process.env.USER_NAME,
    password: process.env.PASSWORD,
    port: process.env.PORT,
    database: 'bugs'
});

// Attempt Connection
connection.connect(function(err) {
    if (err) throw err;
    console.log("Connected");
});

module.exports = connection;
</pre>
</div>

<div class="article-code">
<pre>
// routes.js

module.exports = function(app) {
    var reports = require('../controller/controller');

    app.route('/reports')
        .get(reports.list_all_reports)
        .post(reports.create_a_report);

    app.route('/reports/:reportID')
        .get(reports.get_a_report)
        .put(reports.update_a_report)
        .delete(reports.delete_a_report);
    
    app.route('/filter')
        .post(reports.get_reports_by_type);
};
</pre>
</div>

I setup up a controller to take care of the routes, and a model to handle the SQL queries.
Most of the queries were fairly straight forward; however, I did have to get a bit creative with how to handle multiple report types. Luckily template literals came to the rescue and made things quite concise:

<div class="article-code">
<pre>
Report.getReportsByType = function(reportTypes, result) {
    // reportTypes contain array, need to convert to ('a','b') format
    let list = JSON.stringify(reportTypes.reportTypes).slice(1, -1); 
    mysql.query(`SELECT * FROM reports WHERE type IN (${list})`, function (err, res) {
        if (err) {
            result(err, null);
        }
        else {
            result(null, res);
        }
    })
}
</pre>
</div>

With everything configured, I ran the server via nodemon and pulled up Postman for a test:

<img class="myImg" src="/post_images/bug_server_test.PNG">

Perfect! Looks like the backend is working correctly and pulling the correct information from the server. The post requests worked as well. Taking a peak at our table, we can see the entries are being added correctly:

<img class="myImg" src="/post_images/reports_table.PNG">

### <a id="BugReport-Frontend"></a> Frontend

The frontend is always enjoyable to create. It's nice see all the components from the database and backend come together and form an interactable application. VueJS is my framework of choice to get the job done. The way that it handles components and reactivity is so incredibly convenient and intuitive. I brought in Vuetify to quickly generate the UI components that I needed. Here's a quick mock-up of how I invisioned the Bug Report dashboard:

<img class="myImg" src="/post_images/report_mockup.png">

For an MVP, I really just wanted to have a simple trendline visualizer, a trendline controller (selector), and a table that could filter all our data. For something as structured as this, I chose to wrap everything in a simple flexbox, where each component lives in it's own item:

<div class="article-code">
<pre>
// App.vue

&lt;template&gt;
  &lt;v-app id="app"&gt;
    &lt;div id="title"&gt;Bug Reporter&lt;/div&gt;
    &lt;div id="container"&gt;
      &lt;div id="item1" class="widget"&gt;
        Trends
        &lt;ChartContainer/&gt;
      &lt;/div&gt;
      &lt;div id="item2" class="widget"&gt;
        Report Types
        &lt;SelectionControl/&gt;
      &lt;/div&gt;
      &lt;div class="break"&gt;&lt;/div&gt;
      &lt;div id="item3" class="widget"&gt;
        &lt;DataTable/&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/v-app&gt;
&lt;/template&gt;
</pre>
</div>

For the Trends chart, I discoved a very useful VueJS addon called vue-chartjs (built ontop of chart.js). With this I was able to create a very robust trendline to capture the occurences of reports. I have to add that for the sake of the MVP I chose to display hourly occurences only. The result was quite pleasing:

<img class="myImg" src="/post_images/report_trendline.png">

For the chart controls, I was able to utilize a list-groupe from vuetify. This component comveniently handles the creation of the list items and handles their actions. All I needed it to do was store a list of select report types, and then trigger our backend API to update the chart. I created a short method to handle this:

<div class="article-code">
<pre>
&lt;script&gt;
export default {
  data: () => ({
    items: ["Crash", "MemoryLeak", "NullReference", "Undefined", "VertexShader"],
    reportTypes: [],
  }),

  methods: {
    updateTypeList: function (type) {
      let index = this.reportTypes.indexOf(type);
        if (index > -1) {
          this.reportTypes.splice(index, 1);
        }
        else {
          this.reportTypes.push(type);
        }
        console.log(this.reportTypes);

        this.$root.$emit('ChartContainer', this.reportTypes);
    },
  },
};
&lt;/script&gt;
</pre>
</div>

<img class="myImg" src="/post_images/reports_selector.PNG">

The line: "this.$root.$emit('ChartContainer', this.reportTypes);" is what ties this component together with it's sibling ChartContainer component. When an option is checked, it 'emits' the information (stored in this.reportTypes). I've told ChartContainer.vue to listen for this emitter:

<div class="article-code">
<pre>
  async mounted() {
    this.$root.$on("ChartContainer", (selectedTypes) => {
      this.updateChart(selectedTypes);
    });
  ...
</pre>
</div>

And when it's heard, I make a fetch request to the server with that information!
Now, a design challenge I faced was determining how to format the recieved JSON data so that it played nicely with vue-chartjs. This is what it looks like without being parsed:

<div class="article-code">
<pre>
(21) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
0: {id: 15, type: "VertexShader", comment: "Those pesky vertexes...", timestamp: "2020-09-14T17:05:52.000Z", 
  date: "2020-09-14T04:00:00.000Z", …}
1: {id: 16, type: "VertexShader", comment: "Those pesky vertexes...", timestamp: "2020-09-14T17:05:52.000Z", 
  date: "2020-09-14T04:00:00.000Z", …}
2: {id: 17, type: "VertexShader", comment: "Those pesky vertexes...", timestamp: "2020-09-14T17:05:52.000Z", 
  date: "2020-09-14T04:00:00.000Z", …}
3: {id: 18, type: "VertexShader", comment: "Those pesky vertexes...", timestamp: "2020-09-14T17:05:52.000Z", 
  date: "2020-09-14T04:00:00.000Z", …}
  .
  .
  .
</pre>
</div>

The chart data expects a numerical value for the y-axis, which in this case is the number of occurences. With this I was debating whether or not to handle the 'occurence count' from the frontend or the backend. Both would essentially do the same thing: based on the entry type, count the number of occurence for any given hour. I discovered a creative way of doing it using the .reduce() function, and opted to place it in the frontend for simplicity:

<div class="article-code">
<pre>
  // Tally the number of occurences per hour
  let group = res.data.reduce((occ, it) => {
    occ[it.hour] = occ[it.hour] + 1 || 1;
    return occ;
  }, {});

  this.testData.ocurrencesByHour = Object.keys(group); // Extract occurences as an array
  this.testData.hours = Object.values(group); // Extract hours as an array
</pre>
</div>

So now are data becomes:

<div class="article-code">
<pre>
// Hours
["13", "15", "17", "20"]

// Occurences 
[5, 3, 6, 7]
</pre>
</div>

In action:

<img class="myImg" src="/post_images/report_trendline_anim.gif">

Last but not least was the data table. Another good thing about vuetify is that it has these greate data table components that handle alot of the filtering for you. As long as you have your data objects setup correctly it's pretty much plug-n-play. All I had to do was pass the response data in to the :items prop of the data table. It works really nicely:

<img class="myImg" src="/post_images/report_table_anim.gif">


### <a id="BugReport-Crash-Reporter"></a> Crash Reporter

As an extra step, I thought I would mimic a crash report sequence. Like many of us have experienced before: our game client crashes, and this little crash report window appears at the center of the screen. It tells a bit about what's happened, and requests feedback for analysis.

I've worked with Windows Forms Apps (C#/.NET) before so I thought would be a great platform to try this out on. It also turns out that MySQL has a .NET Connector that makes queries really straightforward:

<div class="article-code">
<pre>
string connectionString;
MySqlConnection conn;

connectionString = "server=127.0.0.1;port=3306;uid=Rudy;pwd=manonmyshoulder;database=bugs";

try
{
    conn = new MySqlConnection();
    conn.ConnectionString = connectionString;
    conn.Open();

  ...
</pre>
</div>

Once the connection is established, I can grab any data in the form and execute the SQL statement. I chose a hardcoded error type for now (VertexShader).

<div class="article-code">
<pre>
// Grab Error Type
string errorType = "VertexShader";

// Grab comments
string comments = "";
comments = textBox1.Text;

// Grab date, hour, and minute
DateTime date = DateTime.Today;
int hour = DateTime.Now.Hour;
int minute = DateTime.Now.Minute;

MySqlCommand comm = conn.CreateCommand();
comm.CommandText = "INSERT INTO reports(type, comment, date, hour, minute) VALUES(?type, ?comment, ?date, ?hour, ?minute)";
comm.Parameters.Add("?type", MySqlDbType.VarChar).Value = errorType;
comm.Parameters.Add("?comment", MySqlDbType.VarChar).Value = comments;
comm.Parameters.Add("?date", MySqlDbType.Date).Value = date;
comm.Parameters.Add("?hour", MySqlDbType.Int16).Value = hour;
comm.Parameters.Add("?minute", MySqlDbType.Int16).Value = minute;
comm.ExecuteNonQuery();
</pre>
</div>

<img class="myImg" src="/post_images/report_form.PNG">

Here it is in action:

<img class="myImg" src="/post_images/report_form_anim.gif">


I hope you enjoyed my project! All source code can be found on my github:

<https://github.com/RudyLang/BugReporter><br>
<https://github.com/RudyLang/BugReportForm>

Cheers,<br>
__Rudy__